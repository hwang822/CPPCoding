#include <cppcoding.h>

// move from (0,0) to (M,N) node with some balcked nodes.

const int M = 4;
const int N = 5;
bool RoadMap(bool map[M][N], int M, int N, int m, int n){

    if((m>=M)||(n>=N)){
        cout << "(" << m << "," << n << ") out of range." << endl;
        return false;
    }

    if ((m==M-1)&&(n==N-1)) {
        cout << "(" << m << "," << n << ") ended" << endl;
        return true;
    }

    if(map[m][n]==true){
        cout << "(" << m << "," << n << ") visted or blacked" << endl;
        return false;
    }
    else
    {
        cout << "(" << m << "," << n << ") visted" << endl;
        map[m][n]=true;
    }

    bool found = false;
    if(m<M-1)
        found = RoadMap(map, M, N, m+1, n);
    if(!found){
        if(n<N-1)
            found = RoadMap(map, M, N, m, n+1);
    }
    return found;
}

//283. Move Zeroes
int* MoveZeroes(int nmus[], int size){
    int iIndex = 0;        
    for(int i = 0; i<size; i++){
        if(nmus[i]!=0){
            nmus[iIndex++] = nmus[i];
        }
    }
    for(int i = iIndex; i<size; i++){
        nmus[i] = 0;
    }

}

//325 Maximum Size Subarray Sum Equals n
int MaximumSizeSubarraySumEqualsN(int nums[], int size, int n){

    int maxSize = 0;
    int curr;
    for(int i=0; i<size; i++){
        curr = nums[i];
        if (curr==n) return 1;
        for(int j=i+1; j<size; j++){
            curr = curr + nums[j];
            if(curr==n)
                if(maxSize<(j-i+1))
                    maxSize=j-i+1;
        }
    }

}

//GeeksForGeeks.org facebook

//1. Inplace rotate square matrix by 90 degrees | Set 1
//对称array, 从两段向里， x=0->N-1-x, y=0->N-1-y. 4角对称 y=x, NxN  (x,x) .. (N-1-x, x)            (0,0)   .. (N-1, 0)
//                                                               .           .                  .           .
//                                                               .           .                  .           .
//                                                              (x,N-1-x) .. (N-1-x, N-1-x)    (0,N-1) .. (N-1, N-1)
/*Input
 1  2  3
 4  5  6
 7  8  9

Output:
 3  6  9
 2  5  8
 1  4  7 */

//
//y=x, divid half to
// x: 0->N/2
// y: x->N-1-x
// (x,y) <-- (y, N-1-x)
//   ^            |
//   |            |
//   |            v
// (N-1-y,x) <-- (N-1-y, N-1-x)

//const int N = 4;

void displayMatrix(int mat[N][N])
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
            printf("%2d ", mat[i][j]);

        printf("\n");
    }
    printf("\n");
}

void Inplacerotatesquarematrixby90degrees(int mat[][N]){
    // Consider all squares one by one
    for (int x = 0; x < N / 2; x++)
    {
        // Consider elements in group of 4 in
        // current square
        for (int y = x; y < N-x-1; y++)
        {
            // store current cell in temp variable
            int temp = mat[x][y];

            // move values from right to top
            mat[x][y] = mat[y][N-1-x];

            // move values from bottom to right
            mat[y][N-1-x] = mat[N-1-x][N-1-y];

            // move values from left to bottom
            mat[N-1-x][N-1-y] = mat[N-1-y][x];

            // assign temp to left
            mat[N-1-y][x] = temp;
        }
    }
    displayMatrix(mat);
}

//2. Largest subset whose all elements are Fibonacci numbers
// 先将 通过算式 产生的 keys 存放在 hash tabe 如 fis, max, coustant, combing vause. 然后再从 nums compare hash table

#include <algorithm>
#include <unordered_set>

void findFibSubset(int arr[], int n){

    // Find maximum element in arr[]
    int max = *std::max_element(arr, arr+n);

    // Generate all Fibonacci numbers till
    // max and store them in hash.
    int a = 0, b = 1;
    unordered_set<int> hash;
    hash.insert(a);
    hash.insert(b);
    while (b < max)
    {
        int c = a + b;
        a = b;
        b = c;
        hash.insert(b);
    }

    // Npw iterate through all numbers and
    // quickly check for Fibonacci using
    // hash.
    for (int i=0; i<n; i++)
        if (hash.find(arr[i]) != hash.end())
            printf("%d ", arr[i]);

    printf("\n");

}

//3. Largest Rectangular Area in a Histogram

int LargestRectangularAreaInAHistogram(int bars[], int size){
    int maxArea = 0;
    if(size<2)
        return maxArea;
    int max = *std::max_element(bars, bars+size);
    int area = 0;
    for(int i = max; i>=1; i-- ){
        area = 0;
        for(int j=0; j<size; j++){
            if(bars[j]>=i){
                area = area + i;
                if(area > maxArea)
                    maxArea = area;
            }
            else
                area = 0;
        }
    }
    return maxArea;
}

//4 Look-and-Say Sequence.  n’th term in generated by reading (n-1)’th term.
#include <string>

string getString(string sSeg){
    string sTemp = "";
    int iCount = 0;
    int i = 0;
    char prv;
    for(i=0; i<sSeg.length();i++){
        if(i==0)
        {
            prv = sSeg[i];
            iCount++;
        }
        else
        {
            if(prv!=sSeg.at(i)){
               sTemp = sTemp + to_string(iCount) + prv;
               iCount = 1;
               prv = sSeg.at(i);
            }
            else {
                iCount++;
            }
         }
    }
    sTemp = sTemp + to_string(iCount) + prv;

    return sTemp;
}

string Look_and_Say_Sequence(int n){

    string sReg = "";
    int iCount = 0;
    for(int j=1; j<=n; j++){
        if(j==1)
            sReg = "1";
        else if(j==2)
            sReg = "11";
        else
            sReg = getString(sReg);
    }
    return sReg;
}

//5.  Program to convert Roman Numerals to Numbers
// This function returns value of a Roman symbol
int value(char r)
{
    if (r == 'I')
        return 1;
    if (r == 'V')
        return 5;
    if (r == 'X')
        return 10;
    if (r == 'L')
        return 50;
    if (r == 'C')
        return 100;
    if (r == 'D')
        return 500;
    if (r == 'M')
        return 1000;

    return -1;
}

// Returns decimal value of roman numaral
int romanToDecimal(string &str)
{
    // Initialize result
    int res = 0;

    // Traverse given input
    for (int i=0; i<str.length(); i++)
    {
        // Getting value of symbol s[i]
        int s1 = value(str[i]);

        if (i+1 < str.length())
        {
            // Getting value of symbol s[i+1]
            int s2 = value(str[i+1]);

            // Comparing both values
            if (s1 >= s2)
            {
                // Value of current symbol is greater
                // or equal to the next symbol
                res = res + s1;
            }
            else
            {
                res = res + s2 - s1;
                i++; // Value of current symbol is
                     // less than the next symbol
            }
        }
        else
        {
            res = res + s1;
            i++;
        }
    }
    return res;
}

//6. Smallest subarray with sum greater than a given value

int SmallestSubarrayWithSumGreaterThanAGivenValue(int nums[], int n){

    int smallest = n+1;
    int curr;
    for(int i=0; i<n; i++){
        curr = nums[i];
        if (curr>n) return 1;
        for(int j=i+1; j<n; j++){
            curr = curr + nums[j];
            if(curr>n)
                if(smallest>(j-i+1))
                    smallest=j-i+1;
        }
    }

    return smallest;
}

//7. Greedy Algorithms

//8. Find Subarray with given sum

int FindSubarrayWithGivenSum(int nums[], int size, int n){
    int curr = 0;
    for(int i=0; i<size; i++){
        curr = nums[i];
        for(int j=i+1; j<size; j++){
            if(curr==n){
                printf("find item equal sum at %d and %d", i, j);
                return 1;
            }
            if((curr > n) || (j == size))
                break; //no more forward
            curr = curr + nums[j];

        }
    }
    printf("No subarry found");
    return 0;
}

//9 Convert Ternary Expression to a Binary Tree
struct Node{
    string item;
    Node *left;
    Node *right;
    Node(char data){
        item = data;
        left = NULL;
        right = NULL;};
};

void printTree(Node *root){
    if(!root)
        return;

    cout<<root->item<<" ";
    printTree(root->left);
    printTree(root->right);

}


Node* ConvertTernaryExpressionToABinaryTree(string TExpr, int i)
{
    if(i>=TExpr.length())
        return NULL;

    Node* root = new Node(TExpr.at(i));
    i++;

    if((i<TExpr.length())&&(TExpr.at(i)=='?'))
        root->left = ConvertTernaryExpressionToABinaryTree(TExpr, i+1);
    else if (i<TExpr.length())
        root->right = ConvertTernaryExpressionToABinaryTree(TExpr, i+1);
    return root;
}

//10 Find All Triplets with zero sum

void FindAllTripletsWithZeroSum(int nums[], int size){
    for(int i=0; i<size; i++){
        for(int j=i+1; j<size; j++){
            for(int k=j+1; k<size; k++){
                if(nums[i] + nums[j] + nums[k]==0)
                    printf("sum zeor at %i, %i, %i\n", nums[i], nums[j], nums[k]);
            }
        }
    }
}

//11 Converting Decimal Number Lying Between 1 to 3999 to Roman Numberals

//12. Find Minimum Depth of a Binary Tree
#include<bits/stdc++.h>
/*
struct NODE{
    int data;
    NODE *left;
    NODE *right;
};
*/

int FindMinimumDepthOfABinaryTree(Node *root){

    if(root==NULL)
        return 0;

    if(!(root->left) && (!root->right))
        return 1;

    if(!root->left)
        return FindMinimumDepthOfABinaryTree(root->right) + 1;

    if(!root->right)
        return FindMinimumDepthOfABinaryTree(root->left) + 1;

    return min(FindMinimumDepthOfABinaryTree(root->left),
               FindMinimumDepthOfABinaryTree(root->right)) + 1;

}

int mainfacebook(){
    bool map[M][N] = {{false,false,false,false,false},{false,false,false,false,false},
                      {false,false,false,false,false},{false,false,false,false,false}};
    map[3][0] = true;
    RoadMap(map, 4, 5, 0, 0);
  //  Node *root
    Node *root = new Node(0);
    root->left  = new Node(1);
    root->right = new Node(3);
    root->left->left  = new Node(4);
    root->left->right  = new Node(5);
    cout << "min tree depth = " << FindMinimumDepthOfABinaryTree(root) <<endl;

    int arr1[] = {0, -1, 2, -3, 1};
    FindAllTripletsWithZeroSum(arr1, sizeof(arr1)/sizeof(arr1[0]));

    string expression = "a?b?c:d:e";
    root = ConvertTernaryExpressionToABinaryTree(expression, 0);
    printTree(root);


    printTree(root);
    int arrs[] = {15, 2, 4, 8, 9, 5, 10, 23};

    FindSubarrayWithGivenSum(arrs, sizeof(arrs)/sizeof(arrs[0]), 23);

    string str ="MCMIV";
    cout << "Integer form of Roman Numeral is "
         << romanToDecimal(str) << endl;
    printf(" gerenatd %s \n", Look_and_Say_Sequence(5));

    int bar[] = {6, 2, 5, 4, 5, 1, 6};
    printf("Max Area %d\n", LargestRectangularAreaInAHistogram(bar, sizeof(bar)/sizeof(bar[0])));

    int arr[] = {4, 2, 8, 5, 20, 1, 40, 13, 23};
    int n = sizeof(arr)/sizeof(arr[0]);
    findFibSubset(arr, n);

    int mat[N][N] =
    {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {13, 14, 15, 16}
    };

    Inplacerotatesquarematrixby90degrees(mat);

    int nums[] = {0,1,0,3,12};
    MoveZeroes(nums, sizeof(nums)/sizeof(int));
    int nums1[] = {1,-1,5,-2,3};
    MaximumSizeSubarraySumEqualsN(nums1, sizeof(nums1)/sizeof(int), 3);

}
